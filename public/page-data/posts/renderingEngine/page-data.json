{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/renderingEngine","result":{"data":{"markdownRemark":{"id":"a0e1e867-83d0-5acf-a21a-70537a29af20","html":"<h1 id=\"렌더링-엔진\" style=\"position:relative;\"><a href=\"#%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%97%94%EC%A7%84\" aria-label=\"렌더링 엔진 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>렌더링 엔진</h1>\n<ul>\n<li>Html/ Xml와 이미지 같은 요청한 컨텐츠를 브라우저 화면에 표시한다.</li>\n<li>-</li>\n</ul>\n<h2 id=\"render-tree-생성\" style=\"position:relative;\"><a href=\"#render-tree-%EC%83%9D%EC%84%B1\" aria-label=\"render tree 생성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Render Tree 생성</h2>\n<h4 id=\"html-parsing\" style=\"position:relative;\"><a href=\"#html-parsing\" aria-label=\"html parsing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTML Parsing</h4>\n<ul>\n<li>HTML텍스트를 읽어 AST를 형성 -> 파싱</li>\n<li>어휘분석\n텍스트를 읽어 토큰을 형성한다. (타입, 값)으로 형성하여 모든 읽어들인 텍스트를 유효하게 구성된 집합으로 만든다. 공백/ 줄바꿈은 제거한다.</li>\n<li>구문분석\n위에서 토큰화한 데이터를 해당 언어의 구문 규칙에 따라 분해하는 과정이다. (시작태그. 종료태그, 속성이름, 속성 값)</li>\n<li>구문분석 데이터 파싱\n구문 규칙에 따라 생성한 데이터를 조합해 파싱 트리html-(DOM) css-(CSSOM)를 생성한다.\n&#x3C;반복>\n어휘분석으로 얻어진 토큰을 구문 규칙에 따라 분해한 데이터를 생성하고 해당 데이터에 해당하는 노드는 파싱트리(DOM)에 추가된다.</li>\n<li>파싱트리\n콘텐츠트리 내부에서 DOM 요소와 속성 노드의 트리로서, 출력 트리가 된다. HTML 문서의 객체로서 외부 컨텐츠를 요청하는 (예 자바스크립트, CSS)와 같은 요소와 연결되는 지점이다.\n브라우저와 자바스크립트가 이해 가능한 트리구조의 객체이다.</li>\n<li>렌더트리\n<code class=\"language-text\">{display:none}</code>의 속성이 적용된 노드는 렌더트리에 존재하지 않는다.</li>\n<li>attachment: 렌더 트리를 생성하기 위해 DOM 노드와 시각 정보(CSSOM)을 연결하는 과정</li>\n<li>렌더링 엔진이 HTML을 파싱하는 과정은 해당 파일을 아래로 읽어나가며 순서대로 진행된다.\n읽은 텍스트 토큰화 -> 구문분석하여 토큰을 분해 -> 구문 규칙에 따라 생성된 데이터로 파싱트리 생성 -> 렌더 트리에 배치(reflow) -> 그리기(repaint)</li>\n</ul>\n<h1 id=\"reflow-repaint\" style=\"position:relative;\"><a href=\"#reflow-repaint\" aria-label=\"reflow repaint permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reflow Repaint</h1>\n<h2 id=\"reflow-렌더트리-배치\" style=\"position:relative;\"><a href=\"#reflow-%EB%A0%8C%EB%8D%94%ED%8A%B8%EB%A6%AC-%EB%B0%B0%EC%B9%98\" aria-label=\"reflow 렌더트리 배치 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>reflow (렌더트리 배치)</h2>\n<ul>\n<li>CSS Box모델 : 문서 트리의 요소들이 가지고있는 스타일이 적용된 사각형 박스.\n예를들어, div>span 여러 다양한 형태의 요소들이 있다.\n여기서\n상위 div는 span요소에 따라 최종적으로 판단됨\n상위는 자식엘리먼트의 영향을 받음\ndiv 형제들은 자기 형 노드의 영향을 받음\n어떻게 repaint를 적게할것인가? 변경사항을 한쪽으로 몰아준다.\n변경이 자주일어날 곳은 브라우저에서 디바운싱한다. 유발인자들만 한 함수에 작성해준다.</li>\n</ul>\n<p>아래와 같은경우 좋지 못한 예임으로 속성 변화는 한곳이 몰아주는것이 맞다</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">div.style.width = '96px';\nlet c = a + b;\ndiv.style.height = '48px'</code></pre></div>\n<p>position이 absolute인경우는 자식에만 영향.\n전체 리플로우를 막울수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">div.getBoundingClientRect()\ndiv.offsetWidth\ndiv.getComputedStyle();</code></pre></div>\n<p>호출되는 수만큼 리플로우가 일어난다. 필요한 순간 몰아서 계산해야한다.\n정확한 정보를 찾기위함으로, 다시 그리는 것이아니라 repaint가 일어나지 않는다.</p>\n<p>-> reflow는 복싱에서 쨉과 같다</p>\n<h2 id=\"repaint\" style=\"position:relative;\"><a href=\"#repaint\" aria-label=\"repaint permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>repaint</h2>\n<p>렌더 트리가 탐색되고 호출된다.\n실제 요소들이 픽셀로 그려지도록 변환하는 과정이다.</p>\n<ul>\n<li>변경된 렌더러는 화면 위에 그려진 사각형(Box model)을 무효화하고, paint(이벤트)를 실행시킨다.</li>\n<li>크롬의 경우 렌더러가 별도로 처리해야 하는 과정이라 복잡하게 이루어진다.</li>\n<li>변경된 부분 몇 개의 영역을 합쳐서 효과적으로 OS는 처리하며, 크롬 또한 해당 동작을 모방한다.</li>\n<li>해당 이벤트는 변화가 이루어지는 부분을 합치기 때문에 렌더 상위로 올라가 변화를 준다.</li>\n<li>렌더 트리는 유효한 렌더러까지 올라가서 변화를 주며 탐색을 이어나가고 그 부분까지 자식과 다시 그려진다.</li>\n</ul>\n<p>엘리먼트가 변할 때 마다 새로 그려줘야한다 값이 더 비싸다.(실행비용이 비쌈)\n예를들면\n캔버스위에 svg, html 에니메이션!!\n또는 fixed 한 position의 요소가 opacity를 가져서 겹친 앨리먼트를 또한 그려줘야 하는경우..\n스타일이 복잡하면 회피방법이 거의 없다. 반면에 리플로우 관련 성능 최적화 방법이 많다.</p>\n<p>-> repaint는 복싱으로 따지면 훅날리는거..</p>\n<h3 id=\"이벤트-순환\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%88%9C%ED%99%98\" aria-label=\"이벤트 순환 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이벤트 순환</h3>\n<ol>\n<li>브라우저의 주요 스레드는 이벤트 순환으로 처리하기 위해 무한 순환한다. repaint/reflow 이벤트 처럼 지속적으로 변화가 있는 경우를 위해 대기를 하다 이벤트를 처리한다. while문을 사용하여 처리 - 파이어폭스</li>\n</ol>\n<h3 id=\"dom-위치를-결정하기\" style=\"position:relative;\"><a href=\"#dom-%EC%9C%84%EC%B9%98%EB%A5%BC-%EA%B2%B0%EC%A0%95%ED%95%98%EA%B8%B0\" aria-label=\"dom 위치를 결정하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DOM 위치를 결정하기</h3>\n<ul>\n<li>normal : 렌더 트리에 구성된 객체의 순서에 따라 해당 DOM의 위치가 적용된다. Box model 유형과 면적에 따른다.</li>\n<li>Float : 왼쪽에서 오른쪽 방향으로 배치된다</li>\n<li>Absolute : 객체는 DOM트리 자리와 다른 렌더 트리에 놓인다. ( reflow 성능 최적화에 유용)</li>\n</ul>\n<h2 id=\"렌더링-엔진의-스레드\" style=\"position:relative;\"><a href=\"#%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%97%94%EC%A7%84%EC%9D%98-%EC%8A%A4%EB%A0%88%EB%93%9C\" aria-label=\"렌더링 엔진의 스레드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>렌더링 엔진의 스레드</h2>\n<ol>\n<li>탭 프로세스의 스레드는 단일 스레드로 동작</li>\n<li>통신의 경우 병렬 스레드에 의해 진행될 수 있다.</li>\n</ol>\n<p>레퍼런스\n<a href=\"https://d2.naver.com/helloworld/59361\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">브라우저는 어떻게 동작하는가</a>\n<a href=\"https://github.com/fkling/astexplorer\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Astexplorer</a>\n<a href=\"https://github.com/jamiebuilds/the-super-tiny-compiler\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">SuperTinyCompiler</a></p>","fields":{"slug":"/posts/renderingEngine","tagSlugs":["/tag/frontend/"]},"frontmatter":{"date":"2021-08-05T22:40:32.169Z","description":"렌더링 엔진의 HTML파싱, 렌더트리 배치와 요소 그리는 과정.","tags":["frontend"],"title":"[Frontend] 브라우저 렌더링 엔진이 어떻게 컨텐츠를 그려내는가 "}}},"pageContext":{"slug":"/posts/renderingEngine"}},"staticQueryHashes":["1140640941","251939775","401334301"]}